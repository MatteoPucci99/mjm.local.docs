@page "/projects/{ProjectId}"
@attribute [Authorize]
@rendermode InteractiveServer
@using System.ComponentModel.DataAnnotations
@using System.Security.Cryptography
@using System.Text
@using Mjm.LocalDocs.Core.Abstractions
@using Mjm.LocalDocs.Core.Models
@using Mjm.LocalDocs.Core.Services
@using Mjm.LocalDocs.Infrastructure.Documents
@using Microsoft.AspNetCore.Components.Forms
@inject IProjectRepository ProjectRepository
@inject DocumentService DocumentService
@inject CompositeDocumentReader DocumentReader
@inject NavigationManager Navigation
@inject IDialogService DialogService
@inject ISnackbar Snackbar
@inject IJSRuntime JS

<PageTitle>@(_project?.Name ?? "Progetto") - Local Docs</PageTitle>

@if (_loading)
{
    <MudProgressCircular Color="Color.Primary" Indeterminate="true" Class="mx-auto d-block my-8" />
}
else if (_project is null)
{
    <MudAlert Severity="Severity.Error">Progetto non trovato.</MudAlert>
    <MudButton Variant="Variant.Text" Color="Color.Primary" Class="mt-4" OnClick="@(() => Navigation.NavigateTo("/projects"))">
        Torna alla lista progetti
    </MudButton>
}
else
{
    <MudBreadcrumbs Items="_breadcrumbs" Class="mb-4 px-0" />

    <div class="d-flex justify-space-between align-center mb-4">
        <MudText Typo="Typo.h4">@_project.Name</MudText>
        <MudButton Variant="Variant.Outlined" 
                   Color="Color.Error" 
                   StartIcon="@Icons.Material.Filled.Delete"
                   OnClick="DeleteProjectAsync">
            Elimina Progetto
        </MudButton>
    </div>

    <MudGrid>
        @* Project Info Section *@
        <MudItem xs="12" md="4">
            <MudPaper Class="pa-4" Elevation="2">
                <MudText Typo="Typo.h6" Class="mb-4">Informazioni Progetto</MudText>
                
                <EditForm Model="@_editModel" OnValidSubmit="SaveProjectAsync">
                    <DataAnnotationsValidator />
                    
                    <MudTextField @bind-Value="_editModel.Name"
                                  Label="Nome"
                                  Required="true"
                                  Variant="Variant.Outlined"
                                  Class="mb-4"
                                  MaxLength="100"
                                  Error="@(!string.IsNullOrEmpty(_nameError))"
                                  ErrorText="@_nameError" />
                    
                    <MudTextField @bind-Value="_editModel.Description"
                                  Label="Descrizione"
                                  Variant="Variant.Outlined"
                                  Class="mb-4"
                                  Lines="3"
                                  MaxLength="500" />
                    
                    <MudText Typo="Typo.caption" Class="mud-text-secondary mb-4 d-block">
                        Creato: @_project.CreatedAt.LocalDateTime.ToString("dd/MM/yyyy HH:mm")
                        @if (_project.UpdatedAt.HasValue)
                        {
                            <br />
                            <span>Modificato: @_project.UpdatedAt.Value.LocalDateTime.ToString("dd/MM/yyyy HH:mm")</span>
                        }
                    </MudText>
                    
                    <MudButton ButtonType="ButtonType.Submit"
                               Variant="Variant.Filled"
                               Color="Color.Primary"
                               Disabled="@_saving"
                               FullWidth="true">
                        @if (_saving)
                        {
                            <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                        }
                        Salva Modifiche
                    </MudButton>
                </EditForm>
            </MudPaper>
        </MudItem>

        @* Documents Section *@
        <MudItem xs="12" md="8">
            <MudPaper Class="pa-4" Elevation="2">
                <div class="d-flex justify-space-between align-center mb-4">
                    <MudText Typo="Typo.h6">
                        Documenti (@ActiveDocumentCount)
                        @if (SupersededDocumentCount > 0)
                        {
                            <MudText Typo="Typo.caption" Class="ml-2 mud-text-secondary" Style="display: inline;">
                                + @SupersededDocumentCount versioni precedenti
                            </MudText>
                        }
                    </MudText>
                    @if (SupersededDocumentCount > 0)
                    {
                        <MudSwitch @bind-Value="_showSuperseded" 
                                   Label="Mostra versioni precedenti" 
                                   Color="Color.Primary"
                                   Size="Size.Small" />
                    }
                </div>

                @* File Upload Area with Drag-and-Drop Support *@
                <MudPaper @ondragenter="@SetDragClass"
                          @ondragleave="@ClearDragClass"
                          @ondragend="@ClearDragClass"
                          Outlined="true"
                          Class="@GetDropzoneClass()"
                          Style="border-width: 2px; min-height: 120px; position: relative;">
                    <InputFile OnChange="OnInputFileChanged"
                               multiple
                               accept=".txt,.md,.pdf,.docx,.html,.htm,.json,.xml,.csv"
                               class="absolute mud-width-full mud-height-full overflow-hidden z-10"
                               style="opacity: 0; cursor: pointer;" />
                    @if (_uploading)
                    {
                        <MudProgressCircular Color="Color.Primary" Indeterminate="true" Size="Size.Large" />
                        <MudText Typo="Typo.body2" Class="mt-2">Caricamento in corso...</MudText>
                    }
                    else
                    {
                        <MudIcon Icon="@Icons.Material.Filled.CloudUpload" Size="Size.Large" Color="Color.Primary" />
                        <MudText Typo="Typo.body1" Class="mt-2">
                            Trascina i file qui o clicca per selezionare
                        </MudText>
                        <MudText Typo="Typo.caption" Class="mud-text-secondary">
                            Formati supportati: .txt, .md, .pdf, .docx, .html, .json, .xml, .csv
                        </MudText>
                    }
                </MudPaper>

                @* Search and Filter *@
                <MudTextField @bind-Value="_searchText"
                              Placeholder="Cerca documenti..."
                              Adornment="Adornment.Start"
                              AdornmentIcon="@Icons.Material.Filled.Search"
                              Immediate="true"
                              DebounceInterval="300"
                              Variant="Variant.Outlined"
                              Class="mt-6 mb-4"
                              Clearable="true"
                              OnClearButtonClick="@(() => { _searchText = string.Empty; })" />

                @* Documents DataGrid *@
                @if (_documents.Count == 0)
                {
                    <MudAlert Severity="Severity.Info">
                        Nessun documento caricato. Usa l'area sopra per caricare i tuoi documenti.
                    </MudAlert>
                }
                else
                {
                    <MudDataGrid T="Document"
                                 Items="@FilteredDocuments"
                                 SortMode="SortMode.Single"
                                 Filterable="false"
                                 Hideable="false"
                                 Dense="true"
                                 Striped="true"
                                 Hover="true"
                                 RowStyleFunc="@GetRowStyle">
                        <Columns>
                            <PropertyColumn Property="x => x.FileName" Title="Nome File" Sortable="true">
                                <CellTemplate>
                                    <div class="d-flex align-center">
                                        <MudIcon Icon="@GetFileIcon(context.Item.FileExtension)" 
                                                 Size="Size.Small" 
                                                 Class="mr-2"
                                                 Color="@GetFileColor(context.Item.FileExtension)" />
                                        <MudText Typo="Typo.body2" Style="word-break: break-word;">
                                            @context.Item.FileName
                                        </MudText>
                                    </div>
                                </CellTemplate>
                            </PropertyColumn>
                            <PropertyColumn Property="x => x.VersionNumber" Title="Versione" Sortable="true">
                                <CellTemplate>
                                    <MudChip T="string"
                                             Size="Size.Small"
                                             Color="@(context.Item.IsSuperseded ? Color.Default : Color.Primary)"
                                             Variant="Variant.Outlined">
                                        v@(context.Item.VersionNumber)
                                    </MudChip>
                                    @if (context.Item.IsSuperseded)
                                    {
                                        <MudChip T="string" Size="Size.Small" Color="Color.Warning" Variant="Variant.Filled" Class="ml-1">
                                            Sostituito
                                        </MudChip>
                                    }
                                </CellTemplate>
                            </PropertyColumn>
                            <PropertyColumn Property="x => x.FileExtension" Title="Tipo" Sortable="true" />
                            <PropertyColumn Property="x => x.FileSizeBytes" Title="Dimensione" Sortable="true">
                                <CellTemplate>
                                    @FormatFileSize(context.Item.FileSizeBytes)
                                </CellTemplate>
                            </PropertyColumn>
                            <PropertyColumn Property="x => x.CreatedAt" Title="Data" Sortable="true">
                                <CellTemplate>
                                    @context.Item.CreatedAt.LocalDateTime.ToString("dd/MM/yyyy HH:mm")
                                </CellTemplate>
                            </PropertyColumn>
                            <TemplateColumn Title="Azioni" Sortable="false">
                                <CellTemplate>
                                    @if (context.Item.VersionNumber > 1 || context.Item.ParentDocumentId is not null 
                                         || _documents.Any(d => d.ParentDocumentId == context.Item.Id))
                                    {
                                        <MudTooltip Text="Cronologia versioni">
                                            <MudIconButton Icon="@Icons.Material.Filled.History"
                                                           Size="Size.Small"
                                                           Color="Color.Info"
                                                           OnClick="@(() => ShowVersionHistoryAsync(context.Item))" />
                                        </MudTooltip>
                                    }
                                    @if (!context.Item.IsSuperseded)
                                    {
                                        <MudTooltip Text="Carica nuova versione">
                                            <MudIconButton Icon="@Icons.Material.Filled.UploadFile"
                                                           Size="Size.Small"
                                                           Color="Color.Tertiary"
                                                           OnClick="@(() => UpdateDocumentAsync(context.Item))" />
                                        </MudTooltip>
                                    }
                                    <MudTooltip Text="Scarica">
                                        <MudIconButton Icon="@Icons.Material.Filled.Download"
                                                       Size="Size.Small"
                                                       Color="Color.Primary"
                                                       OnClick="@(() => DownloadDocumentAsync(context.Item))" />
                                    </MudTooltip>
                                    <MudTooltip Text="Elimina">
                                        <MudIconButton Icon="@Icons.Material.Filled.Delete"
                                                       Size="Size.Small"
                                                       Color="Color.Error"
                                                       OnClick="@(() => DeleteDocumentAsync(context.Item))" />
                                    </MudTooltip>
                                </CellTemplate>
                            </TemplateColumn>
                        </Columns>
                    </MudDataGrid>
                }
            </MudPaper>
        </MudItem>
    </MudGrid>
}

@code {
    [Parameter]
    public string ProjectId { get; set; } = string.Empty;

    private bool _loading = true;
    private bool _saving;
    private bool _uploading;
    private Project? _project;
    private List<Document> _documents = [];
    private readonly ProjectEditModel _editModel = new();
    private string? _nameError;
    private string _searchText = string.Empty;
    private bool _showSuperseded;
    private List<BreadcrumbItem> _breadcrumbs = [];
    
    // Drag-and-drop support
    private string _dragClass = string.Empty;
    private const string DefaultDragClass = "mud-border-primary";
    
    private int ActiveDocumentCount => _documents.Count(d => !d.IsSuperseded);
    private int SupersededDocumentCount => _documents.Count(d => d.IsSuperseded);

    private void SetDragClass() => _dragClass = DefaultDragClass;
    private void ClearDragClass() => _dragClass = string.Empty;
    private string GetDropzoneClass() => $"pa-8 d-flex flex-column align-center justify-center cursor-pointer border-dashed {_dragClass}";

    private IEnumerable<Document> FilteredDocuments
    {
        get
        {
            var docs = _showSuperseded 
                ? _documents 
                : _documents.Where(d => !d.IsSuperseded);

            if (!string.IsNullOrWhiteSpace(_searchText))
                docs = docs.Where(d => d.FileName.Contains(_searchText, StringComparison.OrdinalIgnoreCase));

            return docs.OrderByDescending(d => d.CreatedAt);
        }
    }

    protected override async Task OnInitializedAsync()
    {
        await LoadDataAsync();
    }

    private async Task LoadDataAsync()
    {
        _loading = true;
        
        _project = await ProjectRepository.GetByIdAsync(ProjectId);
        
        if (_project is not null)
        {
            _editModel.Name = _project.Name;
            _editModel.Description = _project.Description;
            
            _breadcrumbs =
            [
                new("Dashboard", href: "/", icon: Icons.Material.Filled.Home),
                new("Progetti", href: "/projects", icon: Icons.Material.Filled.Folder),
                new(_project.Name, href: null, disabled: true)
            ];
            
            _documents = (await DocumentService.GetDocumentsByProjectAsync(ProjectId)).ToList();
        }
        
        _loading = false;
    }

    private async Task SaveProjectAsync()
    {
        if (_project is null) return;
        
        _nameError = null;
        
        if (string.IsNullOrWhiteSpace(_editModel.Name))
        {
            _nameError = "Il nome del progetto e' obbligatorio";
            return;
        }

        // Check if name changed and if it already exists
        if (_editModel.Name.Trim() != _project.Name && 
            await ProjectRepository.ExistsByNameAsync(_editModel.Name.Trim()))
        {
            _nameError = "Esiste gia' un progetto con questo nome";
            return;
        }

        _saving = true;
        StateHasChanged();

        try
        {
            var updatedProject = new Project
            {
                Id = _project.Id,
                Name = _editModel.Name.Trim(),
                Description = string.IsNullOrWhiteSpace(_editModel.Description) ? null : _editModel.Description.Trim(),
                CreatedAt = _project.CreatedAt,
                UpdatedAt = DateTimeOffset.UtcNow
            };

            _project = await ProjectRepository.UpdateAsync(updatedProject);
            _breadcrumbs[2] = new(_project.Name, href: null, disabled: true);
            
            Snackbar.Add("Progetto aggiornato con successo!", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Errore durante il salvataggio: {ex.Message}", Severity.Error);
        }
        finally
        {
            _saving = false;
        }
    }

    private async Task DeleteProjectAsync()
    {
        if (_project is null) return;

        var parameters = new DialogParameters<ConfirmDialog>
        {
            { x => x.ContentText, $"Sei sicuro di voler eliminare il progetto \"{_project.Name}\"? Verranno eliminati anche tutti i {_documents.Count} documenti e i dati associati." },
            { x => x.ButtonText, "Elimina" },
            { x => x.Color, Color.Error }
        };

        var options = new DialogOptions { CloseOnEscapeKey = true, MaxWidth = MaxWidth.Small };
        var dialog = await DialogService.ShowAsync<ConfirmDialog>("Conferma Eliminazione", parameters, options);
        var result = await dialog.Result;

        if (result is { Canceled: false })
        {
            var deleted = await ProjectRepository.DeleteAsync(_project.Id);
            if (deleted)
            {
                Snackbar.Add($"Progetto \"{_project.Name}\" eliminato con successo.", Severity.Success);
                Navigation.NavigateTo("/projects");
            }
            else
            {
                Snackbar.Add("Errore durante l'eliminazione del progetto.", Severity.Error);
            }
        }
    }

    private async Task OnInputFileChanged(InputFileChangeEventArgs e)
    {
        ClearDragClass();
        
        var files = e.GetMultipleFiles(10); // max 10 files
        if (files.Count == 0 || _project is null) return;

        _uploading = true;
        StateHasChanged();

        var successCount = 0;
        var errorCount = 0;

        foreach (var file in files)
        {
            try
            {
                // Read file content
                const long maxFileSize = 50 * 1024 * 1024; // 50 MB
                await using var stream = file.OpenReadStream(maxFileSize);
                using var memoryStream = new MemoryStream();
                await stream.CopyToAsync(memoryStream);
                var fileContent = memoryStream.ToArray();

                // Extract text based on file type using the appropriate reader
                var fileExtension = Path.GetExtension(file.Name).ToLowerInvariant();
                string extractedText;
                
                if (DocumentReader.CanRead(fileExtension))
                {
                    var extractionResult = await DocumentReader.ExtractTextAsync(fileContent, fileExtension);
                    if (!extractionResult.Success)
                    {
                        throw new InvalidOperationException(extractionResult.ErrorMessage ?? "Estrazione testo fallita");
                    }
                    extractedText = extractionResult.Text;
                }
                else
                {
                    // Fallback per formati testuali non gestiti dal CompositeDocumentReader
                    extractedText = Encoding.UTF8.GetString(fileContent);
                }
                
                // Compute content hash
                var contentHash = ComputeHash(fileContent);

                var document = new Document
                {
                    Id = Guid.NewGuid().ToString(),
                    ProjectId = _project.Id,
                    FileName = file.Name,
                    FileExtension = Path.GetExtension(file.Name).ToLowerInvariant(),
                    FileContent = fileContent,
                    FileSizeBytes = file.Size,
                    ExtractedText = extractedText,
                    ContentHash = contentHash
                };

                await DocumentService.AddDocumentAsync(document);
                successCount++;
            }
            catch (Exception ex)
            {
                errorCount++;
                Snackbar.Add($"Errore caricamento \"{file.Name}\": {ex.Message}", Severity.Error);
            }
        }

        // Reload documents
        _documents = (await DocumentService.GetDocumentsByProjectAsync(ProjectId)).ToList();
        
        _uploading = false;
        StateHasChanged();

        if (successCount > 0)
        {
            Snackbar.Add($"{successCount} documento/i caricato/i con successo!", Severity.Success);
        }
    }

    private static string ComputeHash(byte[] content)
    {
        var hashBytes = SHA256.HashData(content);
        return Convert.ToHexString(hashBytes).ToLowerInvariant();
    }

    private async Task DownloadDocumentAsync(Document document)
    {
        try
        {
            var fileContent = await DocumentService.GetDocumentFileAsync(document.Id);
            if (fileContent is null)
            {
                Snackbar.Add("File non trovato.", Severity.Error);
                return;
            }

            var base64 = Convert.ToBase64String(fileContent);
            var mimeType = GetMimeType(document.FileExtension);
            
            await JS.InvokeVoidAsync("downloadFile", document.FileName, base64, mimeType);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Errore durante il download: {ex.Message}", Severity.Error);
        }
    }

    private async Task DeleteDocumentAsync(Document document)
    {
        var parameters = new DialogParameters<ConfirmDialog>
        {
            { x => x.ContentText, $"Sei sicuro di voler eliminare il documento \"{document.FileName}\"? Verranno eliminati anche tutti i dati vettoriali associati." },
            { x => x.ButtonText, "Elimina" },
            { x => x.Color, Color.Error }
        };

        var options = new DialogOptions { CloseOnEscapeKey = true, MaxWidth = MaxWidth.Small };
        var dialog = await DialogService.ShowAsync<ConfirmDialog>("Conferma Eliminazione", parameters, options);
        var result = await dialog.Result;

        if (result is { Canceled: false })
        {
            var deleted = await DocumentService.DeleteDocumentAsync(document.Id);
            if (deleted)
            {
                _documents.Remove(document);
                Snackbar.Add($"Documento \"{document.FileName}\" eliminato con successo.", Severity.Success);
                StateHasChanged();
            }
            else
            {
                Snackbar.Add("Errore durante l'eliminazione del documento.", Severity.Error);
            }
        }
    }

    private async Task UpdateDocumentAsync(Document document)
    {
        if (_project is null) return;

        var parameters = new DialogParameters<UpdateDocumentDialog>
        {
            { x => x.Document, document }
        };

        var options = new DialogOptions
        {
            CloseOnEscapeKey = true,
            MaxWidth = MaxWidth.Small,
            FullWidth = true
        };

        var dialog = await DialogService.ShowAsync<UpdateDocumentDialog>(
            "Aggiorna Documento", parameters, options);
        var result = await dialog.Result;

        if (result is { Canceled: false, Data: UpdateDocumentDialog.UpdateDocumentResult uploadResult })
        {
            try
            {
                // Extract text from the new file
                var fileExtension = Path.GetExtension(uploadResult.FileName).ToLowerInvariant();
                string extractedText;

                if (DocumentReader.CanRead(fileExtension))
                {
                    var extractionResult = await DocumentReader.ExtractTextAsync(uploadResult.FileContent, fileExtension);
                    if (!extractionResult.Success)
                    {
                        throw new InvalidOperationException(extractionResult.ErrorMessage ?? "Estrazione testo fallita");
                    }
                    extractedText = extractionResult.Text;
                }
                else
                {
                    extractedText = Encoding.UTF8.GetString(uploadResult.FileContent);
                }

                var contentHash = ComputeHash(uploadResult.FileContent);

                var newVersionDocument = new Document
                {
                    Id = Guid.NewGuid().ToString(),
                    ProjectId = _project.Id,
                    FileName = uploadResult.FileName,
                    FileExtension = fileExtension,
                    FileContent = uploadResult.FileContent,
                    FileSizeBytes = uploadResult.FileContent.Length,
                    ExtractedText = extractedText,
                    ContentHash = contentHash,
                    VersionNumber = document.VersionNumber + 1,
                    ParentDocumentId = document.Id
                };

                await DocumentService.UpdateDocumentAsync(document.Id, newVersionDocument);

                // Reload documents
                _documents = (await DocumentService.GetDocumentsByProjectAsync(ProjectId)).ToList();
                StateHasChanged();

                Snackbar.Add($"Documento \"{uploadResult.FileName}\" aggiornato a v{newVersionDocument.VersionNumber}!", Severity.Success);
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Errore durante l'aggiornamento: {ex.Message}", Severity.Error);
            }
        }
    }

    private static string GetRowStyle(Document document, int _)
    {
        return document.IsSuperseded ? "opacity: 0.55;" : string.Empty;
    }

    private async Task ShowVersionHistoryAsync(Document document)
    {
        var versions = await DocumentService.GetDocumentVersionsAsync(document.Id);
        
        var parameters = new DialogParameters<DocumentVersionHistoryDialog>
        {
            { x => x.Versions, versions },
            { x => x.CurrentDocumentId, document.Id }
        };

        var options = new DialogOptions 
        { 
            CloseOnEscapeKey = true, 
            MaxWidth = MaxWidth.Medium,
            FullWidth = true
        };
        
        await DialogService.ShowAsync<DocumentVersionHistoryDialog>(
            "Cronologia Versioni", parameters, options);
    }

    private static string FormatFileSize(long bytes)
    {
        string[] sizes = ["B", "KB", "MB", "GB"];
        int order = 0;
        double size = bytes;
        
        while (size >= 1024 && order < sizes.Length - 1)
        {
            order++;
            size /= 1024;
        }
        
        return $"{size:0.##} {sizes[order]}";
    }

    private static string GetFileIcon(string extension) => extension.ToLowerInvariant() switch
    {
        ".pdf" => Icons.Custom.FileFormats.FilePdf,
        ".doc" or ".docx" => Icons.Custom.FileFormats.FileWord,
        ".xls" or ".xlsx" => Icons.Custom.FileFormats.FileExcel,
        ".txt" or ".md" => Icons.Material.Filled.TextSnippet,
        ".json" or ".xml" => Icons.Material.Filled.Code,
        ".csv" => Icons.Material.Filled.TableChart,
        ".html" or ".htm" => Icons.Material.Filled.Html,
        _ => Icons.Material.Filled.InsertDriveFile
    };

    private static Color GetFileColor(string extension) => extension.ToLowerInvariant() switch
    {
        ".pdf" => Color.Error,
        ".doc" or ".docx" => Color.Primary,
        ".xls" or ".xlsx" => Color.Success,
        ".txt" or ".md" => Color.Default,
        ".json" or ".xml" => Color.Warning,
        ".csv" => Color.Info,
        ".html" or ".htm" => Color.Secondary,
        _ => Color.Default
    };

    private static string GetMimeType(string extension) => extension.ToLowerInvariant() switch
    {
        ".pdf" => "application/pdf",
        ".doc" => "application/msword",
        ".docx" => "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        ".xls" => "application/vnd.ms-excel",
        ".xlsx" => "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        ".txt" => "text/plain",
        ".md" => "text/markdown",
        ".json" => "application/json",
        ".xml" => "application/xml",
        ".csv" => "text/csv",
        ".html" or ".htm" => "text/html",
        _ => "application/octet-stream"
    };

    private sealed class ProjectEditModel
    {
        [Required(ErrorMessage = "Il nome del progetto e' obbligatorio")]
        [MaxLength(100, ErrorMessage = "Il nome non puo' superare i 100 caratteri")]
        public string Name { get; set; } = string.Empty;

        [MaxLength(500, ErrorMessage = "La descrizione non puo' superare i 500 caratteri")]
        public string? Description { get; set; }
    }
}
